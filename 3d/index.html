<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8">
<title>Third Person Demo</title>
<style>
    html, body {
        margin: 0;
        padding: 0;
        overflow: hidden;
        background: #000;
    }
    #info {
        position: absolute;
        top: 10px;
        left: 10px;
        color: white;
        font-family: monospace;
        z-index: 10;
    }
</style>
</head>
<body>
<div id="info">Click to lock mouse<br>WASD = Move | Space = Jump</div>

<script src="https://cdn.jsdelivr.net/npm/three@0.158.0/build/three.min.js"></script>

<script>
/* =========================
   BASIC SETUP
========================= */
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x202020);

const camera = new THREE.PerspectiveCamera(
    75,
    window.innerWidth / window.innerHeight,
    0.1,
    1000
);

const renderer = new THREE.WebGLRenderer({ antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
document.body.appendChild(renderer.domElement);

/* =========================
   LIGHT
========================= */
scene.add(new THREE.AmbientLight(0xffffff, 0.4));
const dirLight = new THREE.DirectionalLight(0xffffff, 1);
dirLight.position.set(5, 10, 5);
scene.add(dirLight);

/* =========================
   GROUND
========================= */
const grid = new THREE.GridHelper(200, 200, 0x00ffff, 0x444444);
scene.add(grid);

/* =========================
   PLAYER
========================= */
const player = new THREE.Mesh(
    new THREE.CapsuleGeometry(0.5, 1.0, 4, 8),
    new THREE.MeshStandardMaterial({ color: 0x00ffcc })
);
player.position.y = 1;
scene.add(player);

/* =========================
   CONTROLS
========================= */
let keys = {};
document.addEventListener("keydown", e => {
    keys[e.code] = true;
    if (e.code === "Digit1") { buildMode = "wall"; updateGhost(); }
    if (e.code === "Digit2") { buildMode = "floor"; updateGhost(); }
    if (e.code === "Digit3") { buildMode = "stair"; updateGhost(); }
    if (e.code === "Digit4") { buildMode = "cone"; updateGhost(); }
    if (e.code === "Space" && isGrounded) {
        velocityY = JUMP_FORCE;
        isGrounded = false;
    }
});

function updateGhost() {
    if (ghost) scene.remove(ghost);
    ghost = createBuild(buildMode, true);
    scene.add(ghost);
}


document.addEventListener("keyup", e => keys[e.code] = false);

let velocityY = 0;
let isGrounded = true;

const GRAVITY = -0.00515;
const JUMP_FORCE = 0.32;
const GROUND_Y = 1; // gleiche Höhe wie player.position.y
// Mouse look
let yaw = 0;
let pitch = 0;

document.body.addEventListener("click", () => {
    document.body.requestPointerLock();
});

document.addEventListener("mousemove", e => {
    if (document.pointerLockElement !== document.body) return;

    yaw -= e.movementX * 0.002;
    pitch -= e.movementY * 0.002;
    pitch = Math.max(-1.2, Math.min(1.2, pitch));
});

// build
const BUILD_SIZE = 2;
let buildMode = "wall"; // wall | floor | stair | cone
const builds = [];
let ghost = null;

function createBuild(type, ghostMode = false) {
    let geo;
    const mat = new THREE.MeshStandardMaterial({
        color: ghostMode ? 0x00ff00 : 0x888888,
        transparent: ghostMode,
        opacity: ghostMode ? 0.5 : 1
    });

    switch (type) {
        case "wall":
            geo = new THREE.BoxGeometry(BUILD_SIZE, BUILD_SIZE, 0.2);
            break;
        case "floor":
            geo = new THREE.BoxGeometry(BUILD_SIZE, 0.2, BUILD_SIZE);
            break;
        case "stair":
            geo = new THREE.BoxGeometry(BUILD_SIZE, BUILD_SIZE, BUILD_SIZE);
            break;
        case "cone":
            geo = new THREE.ConeGeometry(BUILD_SIZE, BUILD_SIZE, 4);
            break;
    }

    return new THREE.Mesh(geo, mat);
}

ghost = createBuild(buildMode, true);
scene.add(ghost);

function getBuildPosition() {
    const dir = new THREE.Vector3(
        Math.sin(yaw),
        0,
        Math.cos(yaw)
    );

    const pos = player.position.clone().add(dir.multiplyScalar(4));

    pos.x = Math.round(pos.x / BUILD_SIZE) * BUILD_SIZE;
    pos.y = Math.round(pos.y / BUILD_SIZE) * BUILD_SIZE;
    pos.z = Math.round(pos.z / BUILD_SIZE) * BUILD_SIZE;

    return pos;
}

function canPlace(buildMesh) {
    const box = new THREE.Box3().setFromObject(buildMesh);

    for (const b of builds) {
        const otherBox = new THREE.Box3().setFromObject(b);
        if (box.intersectsBox(otherBox)) {
            return false;
        }
    }
    return true;
}


document.addEventListener("mousedown", e => {
    if (e.button !== 0 || !ghost) return;

    if (!canPlace(ghost)) return;

    const build = createBuild(buildMode);
    build.position.copy(ghost.position);
    build.rotation.copy(ghost.rotation);

    builds.push(build);
    scene.add(build);
});

// colision

const downRay = new THREE.Raycaster();
const DOWN = new THREE.Vector3(0, -1, 0);
const PLAYER_HEIGHT = 1; // halbe Höhe vom Capsule

function checkBuildGroundCollision() {
    downRay.set(
        new THREE.Vector3(
            player.position.x,
            player.position.y,
            player.position.z
        ),
        DOWN
    );

    const hits = downRay.intersectObjects(builds, false);

    if (hits.length > 0) {
        const hit = hits[0];

        // nur wenn wir von oben kommen
        if (velocityY <= 0) {
            player.position.y = hit.point.y + PLAYER_HEIGHT;
            velocityY = 0;
            isGrounded = true;
            return true;
        }
    }
    return false;
}

/* =========================
   CAMERA OFFSET
========================= */
const cameraOffset = new THREE.Vector3(0, 2, -5);

/* =========================
   LOOP
========================= */
function canMove(newPos) {
    const playerBox = new THREE.Box3().setFromCenterAndSize(
        newPos.clone().add(new THREE.Vector3(0, PLAYER_HEIGHT/2, 0)), // Center
        new THREE.Vector3(1, PLAYER_HEIGHT, 1) // Capsule approx
    );

    for (const b of builds) {
        const bBox = new THREE.Box3().setFromObject(b);
        if (playerBox.intersectsBox(bBox)) {
            return false;
        }
    }
    return true;
}


function animate() {
    requestAnimationFrame(animate);

    // Player rotation
    player.rotation.y = yaw;

    // Movement
    const speed = 0.08;
    const forward = new THREE.Vector3(
        Math.sin(yaw),
        0,
        Math.cos(yaw)
    );
    const right = new THREE.Vector3(
        Math.cos(yaw),
        0,
        -Math.sin(yaw)
    );

    const moveSpeed = 0.08;

    // Forward / Back
    let forwardMove = new THREE.Vector3();
    if (keys["KeyW"]) forwardMove.add(forward.clone().multiplyScalar(moveSpeed));
    if (keys["KeyS"]) forwardMove.add(forward.clone().multiplyScalar(-moveSpeed));
    let targetPos = player.position.clone().add(forwardMove);
    if (canMove(targetPos)) player.position.copy(targetPos);

    // Right / Left
    let sideMove = new THREE.Vector3();
    if (keys["KeyD"]) sideMove.add(right.clone().multiplyScalar(moveSpeed));
    if (keys["KeyA"]) sideMove.add(right.clone().multiplyScalar(-moveSpeed));
    targetPos = player.position.clone().add(sideMove);
    if (canMove(targetPos)) player.position.copy(targetPos);

    // Camera follow
    const offset = cameraOffset.clone();
    offset.applyAxisAngle(new THREE.Vector3(0,1,0), yaw);
    camera.position.copy(player.position).add(offset);
    camera.lookAt(player.position.x, player.position.y + 1.2, player.position.z);

    // Gravity
    velocityY += GRAVITY;
    player.position.y += velocityY;
    isGrounded = false;

    // Raycast nach unten für Boden und Build-Landing
    downRay.set(
        new THREE.Vector3(player.position.x, player.position.y, player.position.z),
        DOWN
    );
    const hits = downRay.intersectObjects(builds, false);
    let hitY = GROUND_Y;

    if (hits.length > 0) hitY = Math.max(hitY, hits[0].point.y + PLAYER_HEIGHT);

    if (player.position.y <= hitY) {
        player.position.y = hitY;
        velocityY = 0;
        isGrounded = true;
    }


    // Check Build-Collision zuerst
    if (!checkBuildGroundCollision()) {
        // Fallback: Weltboden
        if (player.position.y <= GROUND_Y) {
            player.position.y = GROUND_Y;
            velocityY = 0;
            isGrounded = true;
        }
    }


    // Ghost Preview Update
    if (ghost) {
        const pos = getBuildPosition();
        ghost.position.copy(pos);

        ghost.rotation.y = (buildMode === "wall" || buildMode === "stair") ? yaw : 0;

        const valid = canPlace(ghost);
        ghost.material.color.set(valid ? 0x00ff00 : 0xff0000);
    }

    renderer.render(scene, camera);
}

animate();

/* =========================
   RESIZE
========================= */
window.addEventListener("resize", () => {
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
    renderer.setSize(window.innerWidth, window.innerHeight);
});
</script>
</body>
</html>
