<!DOCTYPE html>
<html lang="de">
    <head>
        <meta charset="UTF-8" />
        <meta name="viewport" content="width=device-width, initial-scale=1.0" />
        <title>sudoku</title>
        <link rel="stylesheet" href="../style.css">
        <style>
            
            #board {
                display: none;
                margin: 24px auto;

                width: min(92vw, 360px);
                aspect-ratio: 1 / 1;
                font-size: calc(100% / 9);

                grid-template-columns: repeat(9, 1fr);
                gap: 2px;
            }
            
            .cell {
                width: 100%;
                aspect-ratio: 1 / 1;

                display: flex;
                align-items: center;
                justify-content: center;

                font-family: 'Burbank';
                font-size: 12em;;
                font-weight: 700;

                color: #ffffff;

                background: linear-gradient(
                    145deg,
                    #0088dc,
                    #9ed8ff,
                    #87cfff,
                    #87cfff
                );
                /* background-size: 400% 400%; */

                border: none;
                border-radius: 5px;

                cursor: pointer;

                transition: all 0.25s ease;
                /* box-shadow: 0 4px 8px rgba(255, 255, 255, 0.75); */
            }

            .cell.enemy-found {
                background: linear-gradient(
                    145deg,
                    #5a2ca0,
                    #ae95de,
                    #957dc4,
                    #957dc4
                );
                color: #ffffff;
            }

            .cell:hover:not(.fixed) {
                /* transform: scale(1.08); */
                /* background-position: 100% 100%; */
                color: #ffff66;
                text-shadow: 1px 1px 3px rgb(255, 255, 255);
                font-size: 15em;
            }

            @keyframes denied {
                0%   { color: #ff0000; }
                100% { color: #ffffff; }
            }

            .cell.denied {
                animation: denied 3.0s ease;
            }

            .subgrid-bottom {
                border-bottom: 2px solid rgba(255, 255, 255, 0.6);
            }

            .subgrid-top {
                border-top: 2px solid rgba(255, 255, 255, 0.6);
            }

            .subgrid-left {
                border-left: 2px solid #ffffff99;
            }

            .subgrid-right {
                border-right: 2px solid rgba(255, 255, 255, 0.6);
            }

        </style>
    </head>
    <body>
        <header class="banner large">
            <a href="../" style="text-decoration: none;"><h1>mor!tz sein<br><span style="font-size:1rem">&lt;html></span>sudoku<span style="font-size:1rem">&lt;/html></span></h1></a>
        </header>
        <div class="loading">warte auf spieler</div>
        <div id="board"></div>

        <script type="module">
            import { ref, get, set, onValue } from "https://www.gstatic.com/firebasejs/10.3.0/firebase-database.js";
            import { db } from "../firebasedata.js";
            import { getIP } from "../utils.js";

            function nextValue(v) {
                if (v === "0") return "1";
                if (v === "9") return "0";
                return String(Number(v) + 1);
            }

            function genKey(len = 5) {
                const c = "abcdefghijklmnopqrstuvwxyz0123456789";
                return Array.from({length:len},()=>c[Math.floor(Math.random()*c.length)]).join("");
            }

            function generateSudoku() {
                const SIZE = 9;
                const EMPTY = 0;

                function shuffle(arr) {
                    return arr.sort(() => Math.random() - 0.5);
                }

                function isValid(board, row, col, num) {
                    for (let i = 0; i < 9; i++) {
                        if (board[row][i] === num) return false;
                        if (board[i][col] === num) return false;
                    }

                    const br = Math.floor(row / 3) * 3;
                    const bc = Math.floor(col / 3) * 3;

                    for (let r = 0; r < 3; r++) {
                        for (let c = 0; c < 3; c++) {
                            if (board[br + r][bc + c] === num) return false;
                        }
                    }
                    return true;
                }

                function fillBoard(board) {
                    for (let r = 0; r < 9; r++) {
                        for (let c = 0; c < 9; c++) {
                            if (board[r][c] === EMPTY) {
                                for (const n of shuffle([1,2,3,4,5,6,7,8,9])) {
                                    if (isValid(board, r, c, n)) {
                                        board[r][c] = n;
                                        if (fillBoard(board)) return true;
                                        board[r][c] = EMPTY;
                                    }
                                }
                                return false;
                            }
                        }
                    }
                    return true;
                }

                function countSolutions(board, limit = 2) {
                    let count = 0;

                    function solve() {
                        for (let r = 0; r < 9; r++) {
                            for (let c = 0; c < 9; c++) {
                                if (board[r][c] === EMPTY) {
                                    for (let n = 1; n <= 9; n++) {
                                        if (isValid(board, r, c, n)) {
                                            board[r][c] = n;
                                            solve();
                                            board[r][c] = EMPTY;
                                            if (count >= limit) return;
                                        }
                                    }
                                    return;
                                }
                            }
                        }
                        count++;
                    }

                    solve();
                    return count;
                }

                let board = Array.from({ length: 9 }, () => Array(9).fill(EMPTY));
                fillBoard(board);

                const solution = board.flat().join("");

                let puzzle = board.map(r => r.slice());
                let positions = shuffle([...Array(81).keys()]);

                for (const pos of positions) {
                    const r = Math.floor(pos / 9);
                    const c = pos % 9;
                    const backup = puzzle[r][c];

                    puzzle[r][c] = EMPTY;

                    const copy = puzzle.map(row => row.slice());
                    if (countSolutions(copy) !== 1) {
                        puzzle[r][c] = backup;
                    }
                }

                return {
                    puzzle: puzzle.flat().join(""),
                    solution
                };
            }

            const IP = await getIP();
            const params = new URLSearchParams(location.search);
            let session = params.get("session");
            const GAME_PATH = "games/sudoku/sessions";

            if (!session) {
                const snap = await get(ref(db, GAME_PATH));
                let target = null;

                if (snap.exists()) {
                    for (const [id,s] of Object.entries(snap.val())) {
                        if (!s.started && Object.keys(s.players||{}).length < 2) {
                            target = id;
                            break;
                        }
                    }
                }

                if (!target) {
                    do target = genKey();
                    while ((await get(ref(db, `${GAME_PATH}/${target}`))).exists());

                    await set(ref(db, `${GAME_PATH}/${target}`), {
                        players:{},
                        started:false,
                        winner:null
                    });
                }

                location.href = `?session=${target}`;
                throw "redirect";
            }

            const sessionRef = ref(db, `${GAME_PATH}/${session}`);
            const snap = await get(sessionRef);
            const data = snap.val();

            let myIndex = null;
            const players = data.players || {};

            for (const [i,ip] of Object.entries(players)) {
                if (ip === IP) myIndex = +i;
            }

            if (myIndex === null && Object.keys(players).length < 2) {
                myIndex = Object.keys(players).length;
                await set(ref(db, `${GAME_PATH}/${session}/players/${myIndex}`), IP);
            }

            const boardEl = document.getElementById("board");
            const loadingEl = document.querySelector(".loading");
            const cells = [];

            for (let i = 0; i < 81; i++) {
                const b = document.createElement("button");
                b.className = "cell";

                const row = Math.floor(i / 9);
                const col = i % 9;

                if (col % 3 === 0 && col !== 0) b.classList.add("subgrid-left");
                if (col % 3 === 2 && col !== 8) b.classList.add("subgrid-right");

                if (row % 3 === 0 && row !== 0) b.classList.add("subgrid-top");
                if (row % 3 === 2 && row !== 8) b.classList.add("subgrid-bottom");

                b.dataset.i = i;
                boardEl.appendChild(b);
                cells.push(b);
            }

            let lastWinner = null;

            onValue(sessionRef, async snap => {
                const s = snap.val();
                if (!s) return;

                if (!s.started && Object.keys(s.players||{}).length === 2) {
                    await set(ref(db, `${GAME_PATH}/${session}/started`), true);
                }

                if (!s.started) return;

                loadingEl.style.display = "none";
                boardEl.style.display = "grid";

                if (!s.puzzle && myIndex === 0) {
                    const g = generateSudoku();
                    await set(ref(db, `${GAME_PATH}/${session}/puzzle`), g.puzzle);
                    await set(ref(db, `${GAME_PATH}/${session}/solution`), g.solution);
                    await set(ref(db, `${GAME_PATH}/${session}/boards`), {
                        0: g.puzzle,
                        1: g.puzzle
                    });
                    return;
                }

                if (!s.boards) return;
                render(s);

                if (s.winner != null && lastWinner !== s.winner) {
                    lastWinner = s.winner;
                    alert(s.winner === myIndex ? "Du hast gewonnen" : "Du hast verloren");
                }
            });

            cells.forEach(btn => {
                btn.onclick = async () => {
                    const i = +btn.dataset.i;
                    const snap = await get(sessionRef);
                    const s = snap.val();

                    if (!s) return;
                    if (s.winner != null) return;

                    if (s.puzzle[i] !== "0") {
                        btn.classList.remove("denied");
                        void btn.offsetWidth;
                        btn.classList.add("denied");
                        return;
                    }

                    let board = s.boards[myIndex].split("");
                    board[i] = nextValue(board[i]);
                    board = board.join("");

                    await set(
                        ref(db, `${GAME_PATH}/${session}/boards/${myIndex}`),
                        board
                    );

                    if (board === s.solution) {
                        await set(
                            ref(db, `${GAME_PATH}/${session}/winner`),
                            myIndex
                        );
                    }
                };
            });

            function getEnemyIndex() {
                return myIndex === 0 ? 1 : 0;
            }

            function render(s) {
                const myBoard = s.boards[myIndex];
                const enemyBoard = s.boards[getEnemyIndex()];

                myBoard.split("").forEach((v, i) => {
                    const cell = cells[i];

                    cell.textContent = v === "0" ? "" : v;

                    cell.classList.toggle("fixed", s.puzzle[i] !== "0");

                    const enemyTouched =
                        s.puzzle[i] === "0" && enemyBoard[i] !== "0";

                    cell.classList.toggle("enemy-found", enemyTouched);
                });
            }
        </script>
    </body>
</html>
