<!DOCTYPE html>
<html lang="de">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>uno</title>
    <link rel="stylesheet" href="../style.css">
    <style>
      #lobby {
        display: flex;
        flex-direction: column;
        align-items: center;
        justify-content: center;
      }

      .loading {
        padding-bottom: 10px;
      }

      #startBtn {
        font-family: 'Burbank', 'Reem Kufi';
        display: none;
        font-size: 2rem;
        margin: 0px;
        padding: 8px;
        border: 3px solid #ffffff55;
        border-radius: 10px;
        transition: transform .2s ease, box-shadow .2s ease;
        background: #ffffff55;

        color: white;

      }

      .active { 
        outline: 3px solid lime
      }

      .card {
        width: 100px;
        height: 150px;
        margin: 5px;
        border-radius: 8px;
        background: var(--card-color, #ffffff);
        border: 4px solid #000;
        outline: 3px solid #000;
        outline-offset: -12px;

        color: rgb(0, 0, 0);
        font-size: 5rem;
        align-items: center;
        justify-content: center;
        text-align: center;
        display: flex;
        transition: transform 0.4s ease, left 0.4s ease, top 0.4s ease;
      }

      .card:hover {
        cursor: pointer;
        box-shadow:
          0 0 0 5px rgb(255, 0, 0);
      }

      #center {
        position: relative;
        display: none;
        gap: 40px;
        justify-content: center;
      }

      #hand {
        position: relative;
        display: flex;
        flex-direction: column;
        align-items: center;
        margin: 20px auto 0 auto;
        width: 100%;
        min-height: 160px;
      }

      #hand button {
        width: 100px;
        height: 150px;
        transition: transform 0.2s ease;
      }

      #playerBar {
        display: flex;
        justify-content: center;
        gap: 75px;
        margin: 12px 0;
      }

      .player {
        display: flex;
        flex-direction: column;
        align-items: center;
        font-size: 0.8rem;
        color: #aaa;
      }

      .player.active {
        color: white;
      }

      .stack {
        position: relative;
        width: 60px;
        height: 40px;
        display: flex;
        justify-content: center;
        align-items: flex-start;
      }

      .stack .back {
        width: 26px;
        height: 38px;
        background: #f8c0cb;
        border: 2px solid #6c555a;
        border-radius: 4px;
        position: absolute;
      }

      .player.playing .stack .back {
        background: rgb(255, 168, 197);
        border: 2px solid rgb(154, 0, 0);
      }

      .player.playing .you {
        color: rgb(154, 0, 0);
      }

      .you {
        text-align: center;
        position: absolute;
        left: 50%;
        top: 50%;
        transform: translate(-50%, -50%);
        font-size: 1.2rem;
        font-weight: bold;
        pointer-events: none;
        font-size: 2rem;
        margin-top: 2px;
        color: #6c555a;
        z-index: 10;
      }

      .hand-row {
        position: relative;
        height: 160px;
        margin: 0 auto;
      }

      .hand-row:not(:last-child) {
        margin-bottom: -80px;
      }

      #direction {
        text-align: center;
        font-size: 1.2rem;
        margin-top: 6px;
      }

      .overlay {
        position: fixed;
        inset: 0;
        background: rgba(0,0,0,0.7);
        display: flex;
        align-items: center;
        justify-content: center;
        z-index: 9999;
      }

      .overlay.hidden {
        display: none;
      }

      .color-card {
        width: 300px;
        height: 450px;
        display: grid;
        grid-template-columns: 1fr 1fr;
        grid-template-rows: 1fr 1fr;
        border-radius: 16px;
        overflow: hidden;
        border: 6px solid black;
      }

      .color-card div {
        cursor: pointer;
      }

      .color-card div[data-color="red"] { background:#ff4444; }
      .color-card div[data-color="yellow"] { background:#ffff66; }
      .color-card div[data-color="green"] { background:#66ff66; }
      .color-card div[data-color="blue"] { background:#6666ff; }

      .color-card div:hover {
        filter: brightness(1.2);
      }
    </style>
  </head>
  <body>
    <header class="banner large">
      <a href="../" style="text-decoration: none;"><h1>mor!tz<br><span style="font-size:1rem">&lt;html&gt;</span>uno<span style="font-size:1rem">&lt;/html&gt;</span></h1></a>
    </header>
    <div id="lobby">
      <div class="loading">warte auf spieler</div>
      <button id="startBtn">spiel starten</button>
    </div>
    <div id="playerBar"></div>
    <div id="center">
      <div id="drawPile" class="card"></div>
      <div id="pile" class="card"></div>
    </div>
    <div id="hand"></div>
    <div id="colorOverlay" class="overlay hidden">
      <div class="color-card">
        <div data-color="red"></div>
        <div data-color="yellow"></div>
        <div data-color="green"></div>
        <div data-color="blue"></div>
      </div>
    </div>

    <script type="module">
      import { ref, get, set, onValue } from "https://www.gstatic.com/firebasejs/10.3.0/firebase-database.js";
      import { db } from "../firebasedata.js";
      import { getIP } from "../utils.js";

      const GAME_PATH = "games/uno/sessions";
      const MAX_PLAYERS = 5;
      let prevTopCard = null;
      let prevTurn = null;
      let pendingPlayAnimation = null;
      let pendingDrawAnimation = null;
      let prevHands = null;
      let lastState = null;
      let pendingColorResolve = null;

      const COLORS = ["red","yellow","green","blue"];
      const VALUES = ["0","1","2","3","4","5","6","7","8","9","skip","reverse","+2"];
      const startBtn = document.getElementById("startBtn");

      function chooseColor() {
        return new Promise(resolve => {
          const overlay = document.getElementById("colorOverlay");
          overlay.classList.remove("hidden");
          pendingColorResolve = resolve;
        });
      }

      function nextAliveTurn(s) {
        s.placements ??= [];
        const ids = Object.keys(s.players).map(Number);
        let t = s.turn;

        do {
          t = (t + s.direction + ids.length) % ids.length;
        } while (
          s.placements.includes(t) ||
          s.players[t].hand.length === 0
        );

        return t;
      }


      document.querySelectorAll(".color-card div").forEach(el => {
        el.onclick = () => {
          const color = el.dataset.color;
          document.getElementById("colorOverlay").classList.add("hidden");
          pendingColorResolve?.(color);
          pendingColorResolve = null;
        };
      });

      function createDeck() {
        const d = [];
        for (const c of COLORS) {
          for (const v of VALUES) {
            d.push({ color:c, value:v });
            if (v !== "0") d.push({ color:c, value:v });
          }
        }
        for (let i=0;i<4;i++) {
          d.push({ color:"white", value:"wild" });
          d.push({ color:"white", value:"+4" });
        }
        return shuffle(d);
      }

      const shuffle = a => a.sort(()=>Math.random()-0.5);

      const IP = await getIP();
      const params = new URLSearchParams(location.search);
      let session = params.get("session");

      function genKey(len=5){
        const c="abcdefghijklmnopqrstuvwxyz0123456789";
        return Array.from({length:len},()=>c[Math.floor(Math.random()*c.length)]).join("");
      }

      if (!session) {
        const snap = await get(ref(db, GAME_PATH));
        let target=null;

        if (snap.exists()) {
          for (const [id,s] of Object.entries(snap.val())) {
            if (!s.started && Object.keys(s.players||{}).length < MAX_PLAYERS) {
              target=id; break;
            }
          }
        }

        if (!target) {
          target=genKey();
          await set(ref(db,`${GAME_PATH}/${target}`),{
            started:false,
            players:{}
          });
        }

        location.href=`?session=${target}`;
        throw "redirect";
      }

      const sessionRef = ref(db,`${GAME_PATH}/${session}`);
      const snap = await get(sessionRef);
      let data = snap.val();

      let myIndex = Object.entries(data.players||{})
        .find(([_,p])=>p.ip===IP)?.[0];

      if (myIndex==null && Object.keys(data.players||{}).length < MAX_PLAYERS) {
        myIndex = Object.keys(data.players||{}).length;
        await set(ref(db,`${GAME_PATH}/${session}/players/${myIndex}`),{
          ip:IP,
          hand:[]
        });
      }

      myIndex = Number(myIndex);

      function showPlacements(s) {
        const overlay = document.getElementById("resultOverlay");
        const text = document.getElementById("resultText");

        const place = s.placements.indexOf(myIndex) + 1;
        const total = Object.keys(s.players).length;

        const colors = ["#ffff00", "#c0c0c0", "#cd7f32"]; // Gold, Silber, Bronze
        const color = place >= 1 && place <= 3 ? colors[place - 1] : "white";

        text.innerHTML = `
          <div style="font-size:3rem;margin-bottom:10px">
            Plazierung<br>
          </div>
          <div style="font-size:6rem;margin-bottom:10px; color: ${color}">
            #${place}
          </div>
        `;

        overlay.classList.remove("hidden");
      }

      function animateFromPlayerStack(playerIndex, cardEl) {
        const pile = document.getElementById("pile");
        const playerEl = document.querySelector(
          `.player[data-player-index="${playerIndex}"]`
        );
        if (!playerEl) return;

        const stackEl = playerEl.querySelector(".stack");
        if (!stackEl) return;

        const clone = cardEl.cloneNode(true);
        clone.style.position = "fixed";
        clone.style.margin = "0";
        clone.style.zIndex = 1000;

        const start = stackEl.getBoundingClientRect();
        const end = pile.getBoundingClientRect();

        clone.style.left = start.left + start.width / 2 - 50 + "px";
        clone.style.top = start.top + "px";

        clone.style.transform = "scale(0.2) rotate(0deg)";

        document.body.appendChild(clone);

        const rot = (Math.random() * 10 - 5).toFixed(1);

        requestAnimationFrame(() => {
          clone.style.transition = "all 0.4s cubic-bezier(.2,.8,.2,1)";
          clone.style.left = end.left + "px";
          clone.style.top = end.top + "px";
          clone.style.transform = `scale(1.1) rotate(${rot}deg)`;
        });

        setTimeout(() => clone.remove(), 400);
      }

      onValue(sessionRef, async snap => {
        const s = snap.val();
        if (!s) return;

        s.placements ??= [];

        const alive = Object.keys(s.players)
          .map(Number)
          .filter(i => !s.placements.includes(i));

        if (alive.length === 1 && !s.placements.includes(alive[0])) {
          s.placements.push(alive[0]); // letzter Platz
          await set(sessionRef, s);
        }

        const loadingText = document.querySelector(".loading");
        const playerCount = Object.keys(s.players || {}).length;

        if (!s.started) {
          loadingText.textContent = `warte auf spieler (${playerCount}/2)`;
        } else {
          loadingText.style.display = "none";
        }

        for (const p of Object.values(s.players)) {
          if (!Array.isArray(p.hand)) p.hand = [];
        }

        prevHands = prevHands || {};
        for (const [i, p] of Object.entries(s.players)) {
          if (!Array.isArray(prevHands[i])) prevHands[i] = [];
        }

        startBtn.style.display =
          !s.started && myIndex === 0 && playerCount >= 2
            ? "block"
            : "none";

        if (!s.started) return;

        if (
          prevTopCard &&
          (s.topCard.value !== prevTopCard.value || s.topCard.color !== prevTopCard.color)
        ) {
          pendingPlayAnimation = {
            player: prevTurn,
            card: structuredClone(s.topCard)
          };
        }

        for (const [i, p] of Object.entries(s.players)) {
          const prev = prevHands[i]?.length ?? 0;
          if (p.hand.length > prev) {
            pendingDrawAnimation = {
              player: Number(i),
              count: p.hand.length - prev
            };
          }
        }

        prevHands = Object.fromEntries(
          Object.entries(s.players).map(([i, p]) => [i, [...p.hand]])
        );

        prevTopCard = structuredClone(s.topCard);
        prevTurn = s.turn;

        render(s);

        if (pendingPlayAnimation) {
          animateFromPlayerStack(
            pendingPlayAnimation.player,
            createGhostCard(pendingPlayAnimation.card)
          );
          pendingPlayAnimation = null;
        }

        if (pendingDrawAnimation) {
          const { player, count } = pendingDrawAnimation;
          for (let i = 0; i < count; i++) {
            setTimeout(() => animateDrawToPlayer(player), i * 150);
          }
          pendingDrawAnimation = null;
        }

        lastState = s;
        if (s.placements?.length === Object.keys(s.players).length) {
          showPlacements(s);
        }
      });


      function createGhostCard(card) {
        const el = document.createElement("div");
        el.className = "card";
        applyCardContent(el, card);

        el.style.setProperty("--card-color",
          card.color==="red" ? "#ff4444" :
          card.color==="yellow" ? "#ffff66" :
          card.color==="green" ? "#66ff66" :
          card.color==="blue" ? "#6666ff" :
          "#ffffff"
        );

        return el;
      }

      startBtn.onclick = async () => {
        const snap = await get(sessionRef);
        const s = snap.val();

        if (!s || s.started) return;
        if (myIndex !== 0) return;

        const deck = createDeck();
        const players = structuredClone(s.players);

        for (const p of Object.values(players)) {
          if (!Array.isArray(p.hand)) p.hand = [];
        }

        for (let i = 0; i < 7; i++) {
          for (const p of Object.values(players)) {
            p.hand.push(deck.pop());
          }
        }

        await set(sessionRef, {
          started: true,
          turn: 0,
          direction: 1,
          drawStack: 0,
          deck,
          topCard: deck.pop(),
          players,
          placements: []
        });
        document.getElementById("lobby").style.display = "none";
        document.getElementById("center").style.display = "flex";
      };



      function animateDrawToPlayer(playerIndex) {
        const drawPile = document.getElementById("drawPile");
        const playerEl = document.querySelector(
          `.player[data-player-index="${playerIndex}"]`
        );
        if (!drawPile || !playerEl) return;

        const stackEl = playerEl.querySelector(".stack");
        if (!stackEl) return;

        const ghost = document.createElement("div");
        ghost.className = "card";
        ghost.textContent = "ðŸ‚ ";
        ghost.style.position = "fixed";
        ghost.style.zIndex = 1000;

        const start = drawPile.getBoundingClientRect();
        const end = stackEl.getBoundingClientRect();

        ghost.style.left = start.left + "px";
        ghost.style.top = start.top + "px";

        ghost.style.transform = "scale(0.2)";

        document.body.appendChild(ghost);

        requestAnimationFrame(() => {
          ghost.style.transition = "all 0.4s cubic-bezier(.2,.8,.2,1)";
          ghost.style.left = end.left + end.width / 2 - 50 + "px";
          ghost.style.top = end.top + "px";
          ghost.style.transform = "scale(0.6)";
        });

        setTimeout(() => ghost.remove(), 400);
      }

      function applyCardContent(el, card) {
        el.innerHTML = "";

        const img = document.createElement("img");
        img.style.width = "90%";
        img.style.height = "90%";
        img.style.objectFit = "contain";
        img.draggable = false;

        switch (card.value) {
          case "skip":
            img.src = "../Assets/cards/skip.png";
            el.appendChild(img);
            break;

          case "reverse":
            img.src = "../Assets/cards/reverse.png";
            el.appendChild(img);
            break;

          case "wild":
            img.src = "../Assets/cards/wild.png";
            el.appendChild(img);
            break;

          default:
            el.textContent = card.value;
        }
      }

      function canPlay(card, top, drawStack) {
        // Strafphase aktiv
        if (drawStack > 0) {
          if (top.value === "+4") {
            return card.value === "+4";
          }
          if (top.value === "+2") {
            return card.value === "+2" || card.value === "+4";
          }
          return false;
        }

        // normale UNO-Regeln
        return (
          card.color === top.color ||
          card.value === top.value ||
          card.color === "white"
        );
      }


      async function playCard(i) {
        const snap = await get(sessionRef);
        const s = snap.val();
        if (s.turn !== myIndex) return;

        const me = s.players[myIndex];
        const card = me.hand[i];
        if (!canPlay(card, s.topCard, s.drawStack)) return;

        me.hand.splice(i,1);
        s.topCard = card;

        if (card.value === "+2") s.drawStack += 2;
        if (card.value === "+4") s.drawStack += 4;
        if (card.value === "reverse") s.direction *= -1;

        let nextTurn = nextAliveTurn(s);
        if (card.value === "skip") {
          nextTurn = nextAliveTurn({ ...s, turn: nextTurn });
        }
        s.turn = nextTurn;

        if (card.color === "white") {
          const chosenColor = await chooseColor();
          s.topCard.color = chosenColor;
        }

        if (me.hand.length === 0 && !s.placements.includes(myIndex)) {
          s.placements.push(myIndex);
        }

        await set(sessionRef, s);
      }

      async function drawCard() {
        const snap = await get(sessionRef);
        const s = snap.val();
        if (s.turn !== myIndex) return;

        const me = s.players[myIndex];
        const n = Math.max(1,s.drawStack||1);

        for (let i=0;i<n;i++) me.hand.push(s.deck.pop());
        s.drawStack=0;
        s.turn = nextAliveTurn(s);


        await set(sessionRef,s);
      }

      function renderPlayerBar(s) {
        const bar = document.getElementById("playerBar");
        bar.innerHTML = "";

        const playerCount = Object.keys(s.players).length;

        for (let i = 0; i < playerCount; i++) {
          const p = document.createElement("div");
          p.className = "player" + (s.turn === i ? " playing" : "");
          p.dataset.playerIndex = i;

          const stack = document.createElement("div");
          stack.className = "stack";

          const stackCount = Math.min(3, s.players[i].hand.length);
          const angles = [-15, 0, 15];
          const offsetsX = [-10, 0, 10];
          const offsetsY = [0, -2, 0];

          for (let c = 0; c < stackCount; c++) {
            const back = document.createElement("div");
            back.className = "back";

            back.style.transform = `translateX(${offsetsX[c]}px) translateY(${offsetsY[c]}px) rotate(${angles[c]}deg)`;
            back.style.zIndex = c;
            stack.appendChild(back);
          }

          if (i === myIndex) {
            const you = document.createElement("div");
            you.className = "you";
            you.textContent = "You";
            stack.appendChild(you);
          }

          p.appendChild(stack);
          bar.appendChild(p);
        }

        let dir = document.getElementById("direction");
        if (!dir) {
          dir = document.createElement("div");
          dir.id = "direction";
          bar.after(dir);
        }

        dir.textContent = s.direction === 1 ? "âž¡ï¸" : "â¬…ï¸";
      }

      function render(s) {
        renderPlayerBar(s);
        const drawPile = document.getElementById("drawPile");
        drawPile.innerHTML = "";

        const backImg = document.createElement("img");
        backImg.src = "../Assets/cards/back.png";
        backImg.style.width = "100%";
        backImg.style.height = "100%";
        backImg.style.objectFit = "contain";
        backImg.draggable = false;
        drawPile.style.setProperty("--card-color", "#000");
        drawPile.style.outline = "none";
        drawPile.appendChild(backImg);

        const pile = document.getElementById("pile");
        pile.innerHTML = "";
        applyCardContent(pile, s.topCard);
        pile.style.transform =
        `rotate(${(Math.random()*10-5).toFixed(1)}deg)`;
        pile.style.setProperty("--card-color",
          s.topCard.color==="red" ? "#ff4444" :
          s.topCard.color==="yellow" ? "#ffff66" :
          s.topCard.color==="green" ? "#66ff66" :
          s.topCard.color==="blue" ? "#6666ff" :
            "#ffffff"
          );

        const handEl = document.getElementById("hand");
        handEl.innerHTML = "";

        const cards = s.players[myIndex].hand;

        const CARD_WIDTH = 100;
        const CARD_GAP = 18;
        const MAX_PER_ROW = 8;

        const containerWidth = handEl.clientWidth;
        const fitPerRow = Math.floor(
          (containerWidth + CARD_GAP) / (CARD_WIDTH + CARD_GAP)
        );

        const cardsPerRow = Math.min(MAX_PER_ROW, Math.max(1, fitPerRow));

        let row = [];

        for (let i = 0; i < cards.length; i++) {
          row.push(cards[i]);

          if (row.length === cardsPerRow || i === cards.length - 1) {
            const rowEl = document.createElement("div");
            rowEl.className = "hand-row";
            rowEl.style.width =
              `${row.length * (CARD_WIDTH + CARD_GAP) - CARD_GAP}px`;

            row.forEach((c, idx) => {
              const b = document.createElement("button");
              b.className = "card";
              applyCardContent(b, c);

              const realIndex = i - row.length + idx + 1;
              const rot = (Math.random() * 6 - 3).toFixed(1);

              b.style.position = "absolute";
              b.style.left = `${idx * (CARD_WIDTH + CARD_GAP)}px`;
              b.style.transform = `rotate(${rot}deg)`;
              b.style.zIndex = idx;
              b.style.fontFamily = "'Burbank', 'Reem Kufi'"

              b.style.setProperty("--card-color",
                c.color==="red" ? "#ff4444" :
                c.color==="yellow" ? "#ffff66" :
                c.color==="green" ? "#66ff66" :
                c.color==="blue" ? "#6666ff" :
                "#ffffff"
              );

              if (canPlay(c, s.topCard, s.drawStack) && s.turn === myIndex)
                b.classList.add("active");


              b.onclick = () => playCard(realIndex);

              rowEl.appendChild(b);
            });

            handEl.appendChild(rowEl);
            row = [];
          }
        }
      }

      document.getElementById("drawPile").onclick = drawCard;

      window.addEventListener("resize", () => {
        if (!lastState) return;
        render(lastState);
      });

    </script>
  </body>
  <div id="resultOverlay" class="overlay hidden">
    <div style="background:#ffffff4d;padding:30px;border:8px solid #ffffff4d;border-radius:16px;color:white;text-align:center">
      <div id="resultText"></div>
    </div>
  </div>
</html>