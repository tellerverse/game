<!DOCTYPE html>
<html lang="de">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0" />
<title>UNO Multiplayer</title>
<link rel="stylesheet" href="../style.css">
<style>
button { font-size:1.4rem;margin:4px;padding:6px }
.active { outline:3px solid lime }

.card {
  width: 100px;
  height: 150px;
  margin: 5px;
  border-radius: 8px;
  background: var(--card-color, #ffffff);
  border: 3px solid #000000;
  color: rgb(0, 0, 0);
  font-size: 3rem;
  align-items: center;
  justify-content: center;
  text-align: center;
  display: flex;
  transition: transform 0.4s ease, left 0.4s ease, top 0.4s ease;
}
.card:hover {
  cursor: pointer;
  border: none;
  box-shadow: 0 0 10px #fff;
  z-index: 999;
}
/* #game {
  position: absolute;
  height: 100%;
  
} */

#center {
  position: relative;
  /* top: 40%; */
  /* left: 50%; */
  /* transform: translate(-50%, -50%); */
  display: flex;
  gap: 40px;
  justify-content: center;
  /* background: #000; */
}

#hand {
  position: relative;
  display: flex;
  flex-direction: column;   /* üî• Reihen untereinander */
  align-items: center;
  margin: 20px auto 0 auto;
  width: 100%;
  /* max-width: 1000px; */
  /* flex-wrap: wrap; */
  /* justify-content: center; */
  /* gap: 12px; */
  min-height: 160px;
  /* background: #000; */
  }

  #hand button {
    width: 100px;   /* feste Breite */
    height: 150px;  /* feste H√∂he */
    transition: transform 0.2s ease;
  }
  /* 
  .card {
  width: 15vw;
  height: calc(15vw * 1.4);
  border-radius: 8px;
  border: 3px solid #000;
  font-size: 3rem;
  display: flex;
  align-items: center;
  justify-content: center;
  transition: transform 0.4s ease, left 0.4s ease, top 0.4s ease;
  } */
  /* ================= PLAYER BAR ================= */
  #playerBar {
    display: flex;
    justify-content: center;
    gap: 24px;
    margin: 12px 0;
    /* background: #000; */
  }

  .player {
    display: flex;
    flex-direction: column;
    align-items: center;
    font-size: 0.8rem;
    color: #aaa;
  }

  .player.active {
    color: white;
  }

  .stack {
    display: flex;
    position: relative; 
  }

  .stack .back {
    width: 26px;
    height: 38px;
    background: #f8c0cb;
    border: 2px solid #6c555a;
    border-radius: 4px;
    margin-left: -10px;
  }

  .player.playing .stack .back {
    background: rgb(255, 168, 197);
    border: 2px solid #a11c1c;
  }

  .player.playing .you {
    color: rgb(255, 0, 0);
  }

  .you {
    position: absolute;
    left: 50%;
    top: 50%;
    transform: translate(-50%, -50%);
    font-size: 1.2rem;
    font-weight: bold;
    pointer-events: none;
    font-size: 1.5rem;
    margin-top: 2px;
    color: rgb(0, 0, 0);
  }

.hand-row {
  position: relative;          /* üî• absolut-positionierte Karten brauchen das */
  height: 160px;               /* Kartenh√∂he */
  width: calc(8 * 65px + 35px);/* exakt 8 Karten */
  margin: 0 auto;
}

.hand-row:not(:last-child) {
  margin-bottom: -80px;        /* üî• √úberlappt nach unten */
}

  /* ================= DIRECTION ================= */
  #direction {
    text-align: center;
    font-size: 1.2rem;
    margin-top: 6px;
  }
</style>
</head>
<body>
<header class="banner large">
  <h1>mor!tz<br><span style="font-size:1rem">&lt;html&gt;</span>uno<span style="font-size:1rem">&lt;/html&gt;</span></h1>
</header>
<div id="playerBar"></div>
<!-- <div id="game"> -->
<div id="center">
  <div id="drawPile" class="card">üÇ†</div>
  <div id="pile" class="card"></div>
</div>
<!-- </div> -->
<div id="hand"></div>


<button id="startBtn" style="display:none">Spiel starten</button>
<script type="module">
import { ref, get, set, onValue } from "https://www.gstatic.com/firebasejs/10.3.0/firebase-database.js";
import { db } from "../firebasedata.js";
import { getIP } from "../utils.js";

/* ================== CONFIG ================== */
const GAME_PATH = "games/uno/sessions";
const MAX_PLAYERS = 5;
let prevTopCard = null;
let prevTurn = null;
let pendingPlayAnimation = null;
let pendingDrawAnimation = null;
let prevHands = null;

/* ================== KARTEN ================== */
const COLORS = ["red","yellow","green","blue"];
const VALUES = ["0","1","2","3","4","5","6","7","8","9","‚è≠Ô∏è","üîÑÔ∏è","+2"];
const startBtn = document.getElementById("startBtn");
function createDeck() {
  const d = [];
  for (const c of COLORS) {
    for (const v of VALUES) {
      d.push({ color:c, value:v });
      if (v !== "0") d.push({ color:c, value:v });
    }
  }
  for (let i=0;i<4;i++) {
    d.push({ color:"wild", value:"wild" });
    d.push({ color:"wild", value:"+4" });
  }
  return shuffle(d);
}

const shuffle = a => a.sort(()=>Math.random()-0.5);

/* ================== SESSION ================== */
const IP = await getIP();
const params = new URLSearchParams(location.search);
let session = params.get("session");

function genKey(len=5){
  const c="abcdefghijklmnopqrstuvwxyz0123456789";
  return Array.from({length:len},()=>c[Math.floor(Math.random()*c.length)]).join("");
}

if (!session) {
  const snap = await get(ref(db, GAME_PATH));
  let target=null;

  if (snap.exists()) {
    for (const [id,s] of Object.entries(snap.val())) {
      if (!s.started && Object.keys(s.players||{}).length < MAX_PLAYERS) {
        target=id; break;
      }
    }
  }

  if (!target) {
    target=genKey();
    await set(ref(db,`${GAME_PATH}/${target}`),{
      started:false,
      players:{}
    });
  }

  location.href=`?session=${target}`;
  throw "redirect";
}

const sessionRef = ref(db,`${GAME_PATH}/${session}`);
const snap = await get(sessionRef);
let data = snap.val();

/* ================== PLAYER ================== */
let myIndex = Object.entries(data.players||{})
  .find(([_,p])=>p.ip===IP)?.[0];

if (myIndex==null && Object.keys(data.players||{}).length < MAX_PLAYERS) {
  myIndex = Object.keys(data.players||{}).length;
  await set(ref(db,`${GAME_PATH}/${session}/players/${myIndex}`),{
    ip:IP,
    hand:[]
  });
}

myIndex = Number(myIndex);

/* ================== INIT ================== */

function animateFromPlayerStack(playerIndex, cardEl) {
  const pile = document.getElementById("pile");
  const playerEl = document.querySelector(
    `.player[data-player-index="${playerIndex}"]`
  );
  if (!playerEl) return;

  const stackEl = playerEl.querySelector(".stack");
  if (!stackEl) return;

  const clone = cardEl.cloneNode(true);
  clone.style.position = "fixed";
  clone.style.margin = "0";
  clone.style.zIndex = 1000;

  const start = stackEl.getBoundingClientRect();
  const end = pile.getBoundingClientRect();

  clone.style.left = start.left + start.width / 2 - 50 + "px";
  clone.style.top = start.top + "px";

  // üî• START: mini
  clone.style.transform = "scale(0.2) rotate(0deg)";

  document.body.appendChild(clone);

  const rot = (Math.random() * 10 - 5).toFixed(1);

  requestAnimationFrame(() => {
    clone.style.transition = "all 0.4s cubic-bezier(.2,.8,.2,1)";
    clone.style.left = end.left + "px";
    clone.style.top = end.top + "px";
    clone.style.transform = `scale(1.1) rotate(${rot}deg)`;
  });

  setTimeout(() => clone.remove(), 400);
}


onValue(sessionRef, snap => {
  const s = snap.val();
  if (!s) return;
  const playerCount = Object.keys(s.players || {}).length;
  startBtn.style.display =
    !s.started && myIndex === 0 && playerCount >= 2
      ? "block"
      : "none";
  if (!s || !s.started) return;
  if (
    prevTopCard &&
    (s.topCard.value !== prevTopCard.value ||
      s.topCard.color !== prevTopCard.color)
  ) {
    pendingPlayAnimation = {
      player: prevTurn,
      card: structuredClone(s.topCard)
    };
  }

  // Karte gezogen
  for (const [i,p] of Object.entries(s.players)) {
    const prev = prevHands?.[i]?.length ?? 0;
    if (p.hand.length > prev) {
      pendingDrawAnimation = {
        player: Number(i),
        count: p.hand.length - prev
      };
    }
  }

  prevHands = Object.fromEntries(
    Object.entries(s.players).map(([i,p]) => [i, [...p.hand]])
  );

  prevTopCard = structuredClone(s.topCard);
  prevTurn = s.turn;

  render(s);

  // üî• JETZT existiert der DOM
  if (pendingPlayAnimation) {
    animateFromPlayerStack(
      pendingPlayAnimation.player,
      createGhostCard(pendingPlayAnimation.card)
    );
    pendingPlayAnimation = null;
  }

  if (pendingDrawAnimation) {
    const { player, count } = pendingDrawAnimation;
    for (let i = 0; i < count; i++) {
      setTimeout(() => {
        animateDrawToPlayer(player);
      }, i * 150); // jede Karte 150ms verz√∂gert
    }
    pendingDrawAnimation = null;
  }
});

function createGhostCard(card) {
  const el = document.createElement("div");
  el.className = "card";
  el.textContent = card.value;

  el.style.setProperty("--card-color",
    card.color==="red" ? "#ff4444" :
    card.color==="yellow" ? "#ffff66" :
    card.color==="green" ? "#66ff66" :
    card.color==="blue" ? "#6666ff" :
    "#ffffff"
  );

  return el;
}

startBtn.onclick = async () => {
  const snap = await get(sessionRef);
  const s = snap.val();

  if (!s || s.started) return;
  if (myIndex !== 0) return;

  const deck = createDeck();
  const players = structuredClone(s.players);

  // üî¥ KRITISCHER FIX
  for (const p of Object.values(players)) {
    if (!Array.isArray(p.hand)) p.hand = [];
  }

  for (let i = 0; i < 7; i++) {
    for (const p of Object.values(players)) {
      p.hand.push(deck.pop());
    }
  }

  await set(sessionRef, {
    started: true,
    turn: 0,
    direction: 1,
    drawStack: 0,
    deck,
    topCard: deck.pop(),
    players,
    winner: null
  });
};



function animateDrawToPlayer(playerIndex) {
  const drawPile = document.getElementById("drawPile");
  const playerEl = document.querySelector(
    `.player[data-player-index="${playerIndex}"]`
  );
  if (!drawPile || !playerEl) return;

  const stackEl = playerEl.querySelector(".stack");
  if (!stackEl) return;

  const ghost = document.createElement("div");
  ghost.className = "card";
  ghost.textContent = "üÇ†";
  ghost.style.position = "fixed";
  ghost.style.zIndex = 1000;

  const start = drawPile.getBoundingClientRect();
  const end = stackEl.getBoundingClientRect();

  ghost.style.left = start.left + "px";
  ghost.style.top = start.top + "px";

  // üî• START: sehr klein
  ghost.style.transform = "scale(0.2)";

  document.body.appendChild(ghost);

  requestAnimationFrame(() => {
    ghost.style.transition = "all 0.4s cubic-bezier(.2,.8,.2,1)";
    ghost.style.left = end.left + end.width / 2 - 50 + "px";
    ghost.style.top = end.top + "px";
    ghost.style.transform = "scale(0.6)";
  });

  setTimeout(() => ghost.remove(), 400);
}



/* ================== LOGIK ================== */
function canPlay(card, top) {
  return (
    card.color === top.color ||
    card.value === top.value ||
    card.color === "wild"
  );
}

async function playCard(i) {
  const snap = await get(sessionRef);
  const s = snap.val();
  if (s.turn !== myIndex || s.winner!=null) return;

  const me = s.players[myIndex];
  const card = me.hand[i];
  if (!canPlay(card,s.topCard)) return;

  me.hand.splice(i,1);
  s.topCard = card;

  if (card.value==="+2") s.drawStack+=2;
  if (card.value==="+4") s.drawStack+=4;
  if (card.value==="üîÑÔ∏è") s.direction*=-1;
  if (card.value==="‚è≠Ô∏è")
    s.turn = (s.turn + s.direction + Object.keys(s.players).length) % Object.keys(s.players).length;

  if (card.color==="wild")
    s.topCard.color = prompt("Farbe (red/yellow/green/blue)");

  if (me.hand.length===0) s.winner=myIndex;

  s.turn = (s.turn + s.direction + Object.keys(s.players).length) % Object.keys(s.players).length;
  await set(sessionRef,s);
}

async function drawCard() {
  const snap = await get(sessionRef);
  const s = snap.val();
  if (s.turn !== myIndex) return;

  const me = s.players[myIndex];
  const n = Math.max(1,s.drawStack||1);

  for (let i=0;i<n;i++) me.hand.push(s.deck.pop());
  s.drawStack=0;
  s.turn = (s.turn + s.direction + Object.keys(s.players).length) % Object.keys(s.players).length;

  await set(sessionRef,s);
}

function renderPlayerBar(s) {
  const bar = document.getElementById("playerBar");
  bar.innerHTML = "";

  const playerCount = Object.keys(s.players).length;

  for (let i = 0; i < playerCount; i++) {
    const p = document.createElement("div");
    p.className = "player" + (s.turn === i ? " playing" : "");
    p.dataset.playerIndex = i;

    const stack = document.createElement("div");
    stack.className = "stack";

    // Kartenr√ºcken
    for (let c = 0; c < 3; c++) {
      const back = document.createElement("div");
      back.className = "back";
      stack.appendChild(back);
    }

    // üî• "You" INSIDE stack (nur f√ºr dich)
    if (i === myIndex) {
      const you = document.createElement("div");
      you.className = "you";
      you.textContent = "You";
      stack.appendChild(you);
    }

    // üî• Stack IMMER anh√§ngen
    p.appendChild(stack);
    bar.appendChild(p);
  }


  // Richtungspfeil
  let dir = document.getElementById("direction");
  if (!dir) {
    dir = document.createElement("div");
    dir.id = "direction";
    bar.after(dir);
  }

  dir.textContent = s.direction === 1 ? "‚û°Ô∏è" : "‚¨ÖÔ∏è";
}


/* ================== UI ================== */
function render(s) {
  renderPlayerBar(s);


  const pile = document.getElementById("pile");
  pile.textContent =`${s.topCard.value}`;
  pile.style.transform =
  `rotate(${(Math.random()*10-5).toFixed(1)}deg)`;
  pile.style.setProperty("--card-color",
    s.topCard.color==="red" ? "#ff4444" :
    s.topCard.color==="yellow" ? "#ffff66" :
    s.topCard.color==="green" ? "#66ff66" :
    s.topCard.color==="blue" ? "#6666ff" :
      "#ffffff"
    );

  const handEl = document.getElementById("hand");
  handEl.innerHTML = "";

  const cards = s.players[myIndex].hand;
  const maxPerRow = 8;
  let row = [];

  // Reihen vorbereiten
  for (let i = 0; i < cards.length; i++) {
    row.push(cards[i]);

    if (row.length === maxPerRow || i === cards.length - 1) {
      const rowEl = document.createElement("div");

      rowEl.className = "hand-row";
      // rowEl.style.display = "flex";
      // rowEl.style.gap = "12px";

      row.forEach((c, idx) => {
        const b = document.createElement("button");
        b.className = "card";
        b.textContent = c.value;

        b.dataset.index = i - row.length + idx + 1;

        const overlap = 65; // üî• wie stark sie ineinander liegen
        const rot = (Math.random() * 6 - 3).toFixed(1);

        b.style.position = "absolute";
        b.style.left = `${idx * overlap}px`;
        b.style.transform = `rotate(${rot}deg)`;
        b.style.zIndex = idx;
        b.style.fontFamily = "'Burbank', 'Reem Kufi'";

        b.style.setProperty("--card-color",
          c.color==="red" ? "#ff4444" :
          c.color==="yellow" ? "#ffff66" :
          c.color==="green" ? "#66ff66" :
          c.color==="blue" ? "#6666ff" :
          "#ffffff"
        );

        if (canPlay(c, s.topCard) && s.turn === myIndex) b.classList.add("active");

        const realIndex = i - row.length + idx + 1;

        b.onclick = async () => {
          await playCard(realIndex);
        };

        rowEl.appendChild(b);
      });

      // Reihen stapeln, letzte Reihe oben
      handEl.appendChild(rowEl);
      row = [];
    }
  }

}

document.getElementById("drawPile").onclick = drawCard;

</script>
</body>
</html>
